{
  "version": 3,
  "sources": ["../../jsonrepair/src/utils/JSONRepairError.ts", "../../jsonrepair/src/utils/stringUtils.ts", "../../jsonrepair/src/regular/jsonrepair.ts"],
  "sourcesContent": ["export class JSONRepairError extends Error {\n  position: number\n\n  constructor(message: string, position: number) {\n    super(`${message} at position ${position}`)\n\n    this.position = position\n  }\n}\n", "const codeSpace = 0x20 // \" \"\nconst codeNewline = 0xa // \"\\n\"\nconst codeTab = 0x9 // \"\\t\"\nconst codeReturn = 0xd // \"\\r\"\nconst codeNonBreakingSpace = 0xa0\nconst codeEnQuad = 0x2000\nconst codeHairSpace = 0x200a\nconst codeNarrowNoBreakSpace = 0x202f\nconst codeMediumMathematicalSpace = 0x205f\nconst codeIdeographicSpace = 0x3000\n\nexport function isHex(char: string): boolean {\n  return /^[0-9A-Fa-f]$/.test(char)\n}\n\nexport function isDigit(char: string): boolean {\n  return char >= '0' && char <= '9'\n}\n\nexport function isValidStringCharacter(char: string): boolean {\n  // note that the valid range is between \\u{0020} and \\u{10ffff},\n  // but in JavaScript it is not possible to create a code point larger than\n  // \\u{10ffff}, so there is no need to test for that here.\n  return char >= '\\u0020'\n}\n\nexport function isDelimiter(char: string): boolean {\n  return ',:[]/{}()\\n+'.includes(char)\n}\n\nexport function isFunctionNameCharStart(char: string) {\n  return (\n    (char >= 'a' && char <= 'z') || (char >= 'A' && char <= 'Z') || char === '_' || char === '$'\n  )\n}\n\nexport function isFunctionNameChar(char: string) {\n  return (\n    (char >= 'a' && char <= 'z') ||\n    (char >= 'A' && char <= 'Z') ||\n    char === '_' ||\n    char === '$' ||\n    (char >= '0' && char <= '9')\n  )\n}\n\n// matches \"https://\" and other schemas\nexport const regexUrlStart = /^(http|https|ftp|mailto|file|data|irc):\\/\\/$/\n\n// matches all valid URL characters EXCEPT \"[\", \"]\", and \",\", since that are important JSON delimiters\nexport const regexUrlChar = /^[A-Za-z0-9-._~:/?#@!$&'()*+;=]$/\n\nexport function isUnquotedStringDelimiter(char: string): boolean {\n  return ',[]/{}\\n+'.includes(char)\n}\n\nexport function isStartOfValue(char: string): boolean {\n  return isQuote(char) || regexStartOfValue.test(char)\n}\n\n// alpha, number, minus, or opening bracket or brace\nconst regexStartOfValue = /^[[{\\w-]$/\n\nexport function isControlCharacter(char: string) {\n  return char === '\\n' || char === '\\r' || char === '\\t' || char === '\\b' || char === '\\f'\n}\n\nexport interface Text {\n  charCodeAt: (index: number) => number\n}\n\n/**\n * Check if the given character is a whitespace character like space, tab, or\n * newline\n */\nexport function isWhitespace(text: Text, index: number): boolean {\n  const code = text.charCodeAt(index)\n\n  return code === codeSpace || code === codeNewline || code === codeTab || code === codeReturn\n}\n\n/**\n * Check if the given character is a whitespace character like space or tab,\n * but NOT a newline\n */\nexport function isWhitespaceExceptNewline(text: Text, index: number): boolean {\n  const code = text.charCodeAt(index)\n\n  return code === codeSpace || code === codeTab || code === codeReturn\n}\n\n/**\n * Check if the given character is a special whitespace character, some\n * unicode variant\n */\nexport function isSpecialWhitespace(text: Text, index: number): boolean {\n  const code = text.charCodeAt(index)\n\n  return (\n    code === codeNonBreakingSpace ||\n    (code >= codeEnQuad && code <= codeHairSpace) ||\n    code === codeNarrowNoBreakSpace ||\n    code === codeMediumMathematicalSpace ||\n    code === codeIdeographicSpace\n  )\n}\n\n/**\n * Test whether the given character is a quote or double quote character.\n * Also tests for special variants of quotes.\n */\nexport function isQuote(char: string): boolean {\n  // the first check double quotes, since that occurs most often\n  return isDoubleQuoteLike(char) || isSingleQuoteLike(char)\n}\n\n/**\n * Test whether the given character is a double quote character.\n * Also tests for special variants of double quotes.\n */\nexport function isDoubleQuoteLike(char: string): boolean {\n  return char === '\"' || char === '\\u201c' || char === '\\u201d'\n}\n\n/**\n * Test whether the given character is a double quote character.\n * Does NOT test for special variants of double quotes.\n */\nexport function isDoubleQuote(char: string): boolean {\n  return char === '\"'\n}\n\n/**\n * Test whether the given character is a single quote character.\n * Also tests for special variants of single quotes.\n */\nexport function isSingleQuoteLike(char: string): boolean {\n  return (\n    char === \"'\" || char === '\\u2018' || char === '\\u2019' || char === '\\u0060' || char === '\\u00b4'\n  )\n}\n\n/**\n * Test whether the given character is a single quote character.\n * Does NOT test for special variants of single quotes.\n */\nexport function isSingleQuote(char: string): boolean {\n  return char === \"'\"\n}\n\n/**\n * Strip last occurrence of textToStrip from text\n */\nexport function stripLastOccurrence(\n  text: string,\n  textToStrip: string,\n  stripRemainingText = false\n): string {\n  const index = text.lastIndexOf(textToStrip)\n  return index !== -1\n    ? text.substring(0, index) + (stripRemainingText ? '' : text.substring(index + 1))\n    : text\n}\n\nexport function insertBeforeLastWhitespace(text: string, textToInsert: string): string {\n  let index = text.length\n\n  if (!isWhitespace(text, index - 1)) {\n    // no trailing whitespaces\n    return text + textToInsert\n  }\n\n  while (isWhitespace(text, index - 1)) {\n    index--\n  }\n\n  return text.substring(0, index) + textToInsert + text.substring(index)\n}\n\nexport function removeAtIndex(text: string, start: number, count: number) {\n  return text.substring(0, start) + text.substring(start + count)\n}\n\n/**\n * Test whether a string ends with a newline or comma character and optional whitespace\n */\nexport function endsWithCommaOrNewline(text: string): boolean {\n  return /[,\\n][ \\t\\r]*$/.test(text)\n}\n", "import { JSONRepairError } from '../utils/JSONRepairError.js'\nimport {\n  endsWithCommaOrNewline,\n  insertBeforeLastWhitespace,\n  isControlCharacter,\n  isDelimiter,\n  isDigit,\n  isDoubleQuote,\n  isDoubleQuoteLike,\n  isFunctionNameChar,\n  isFunctionNameCharStart,\n  isHex,\n  isQuote,\n  isSingleQuote,\n  isSingleQuoteLike,\n  isSpecialWhitespace,\n  isStartOfValue,\n  isUnquotedStringDelimiter,\n  isValidStringCharacter,\n  isWhitespace,\n  isWhitespaceExceptNewline,\n  regexUrlChar,\n  regexUrlStart,\n  removeAtIndex,\n  stripLastOccurrence\n} from '../utils/stringUtils.js'\n\nconst controlCharacters: { [key: string]: string } = {\n  '\\b': '\\\\b',\n  '\\f': '\\\\f',\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\t': '\\\\t'\n}\n\n// map with all escape characters\nconst escapeCharacters: { [key: string]: string } = {\n  '\"': '\"',\n  '\\\\': '\\\\',\n  '/': '/',\n  b: '\\b',\n  f: '\\f',\n  n: '\\n',\n  r: '\\r',\n  t: '\\t'\n  // note that \\u is handled separately in parseString()\n}\n\n/**\n * Repair a string containing an invalid JSON document.\n * For example changes JavaScript notation into JSON notation.\n *\n * Example:\n *\n *     try {\n *       const json = \"{name: 'John'}\"\n *       const repaired = jsonrepair(json)\n *       console.log(repaired)\n *       // '{\"name\": \"John\"}'\n *     } catch (err) {\n *       console.error(err)\n *     }\n *\n */\nexport function jsonrepair(text: string): string {\n  let i = 0 // current index in text\n  let output = '' // generated output\n\n  parseMarkdownCodeBlock(['```', '[```', '{```'])\n\n  const processed = parseValue()\n  if (!processed) {\n    throwUnexpectedEnd()\n  }\n\n  parseMarkdownCodeBlock(['```', '```]', '```}'])\n\n  const processedComma = parseCharacter(',')\n  if (processedComma) {\n    parseWhitespaceAndSkipComments()\n  }\n\n  if (isStartOfValue(text[i]) && endsWithCommaOrNewline(output)) {\n    // start of a new value after end of the root level object: looks like\n    // newline delimited JSON -> turn into a root level array\n    if (!processedComma) {\n      // repair missing comma\n      output = insertBeforeLastWhitespace(output, ',')\n    }\n\n    parseNewlineDelimitedJSON()\n  } else if (processedComma) {\n    // repair: remove trailing comma\n    output = stripLastOccurrence(output, ',')\n  }\n\n  // repair redundant end quotes\n  while (text[i] === '}' || text[i] === ']') {\n    i++\n    parseWhitespaceAndSkipComments()\n  }\n\n  if (i >= text.length) {\n    // reached the end of the document properly\n    return output\n  }\n\n  throwUnexpectedCharacter()\n\n  function parseValue(): boolean {\n    parseWhitespaceAndSkipComments()\n    const processed =\n      parseObject() ||\n      parseArray() ||\n      parseString() ||\n      parseNumber() ||\n      parseKeywords() ||\n      parseUnquotedString(false) ||\n      parseRegex()\n    parseWhitespaceAndSkipComments()\n\n    return processed\n  }\n\n  function parseWhitespaceAndSkipComments(skipNewline = true): boolean {\n    const start = i\n\n    let changed = parseWhitespace(skipNewline)\n    do {\n      changed = parseComment()\n      if (changed) {\n        changed = parseWhitespace(skipNewline)\n      }\n    } while (changed)\n\n    return i > start\n  }\n\n  function parseWhitespace(skipNewline: boolean): boolean {\n    const _isWhiteSpace = skipNewline ? isWhitespace : isWhitespaceExceptNewline\n    let whitespace = ''\n\n    while (true) {\n      if (_isWhiteSpace(text, i)) {\n        whitespace += text[i]\n        i++\n      } else if (isSpecialWhitespace(text, i)) {\n        // repair special whitespace\n        whitespace += ' '\n        i++\n      } else {\n        break\n      }\n    }\n\n    if (whitespace.length > 0) {\n      output += whitespace\n      return true\n    }\n\n    return false\n  }\n\n  function parseComment(): boolean {\n    // find a block comment '/* ... */'\n    if (text[i] === '/' && text[i + 1] === '*') {\n      // repair block comment by skipping it\n      while (i < text.length && !atEndOfBlockComment(text, i)) {\n        i++\n      }\n      i += 2\n\n      return true\n    }\n\n    // find a line comment '// ...'\n    if (text[i] === '/' && text[i + 1] === '/') {\n      // repair line comment by skipping it\n      while (i < text.length && text[i] !== '\\n') {\n        i++\n      }\n\n      return true\n    }\n\n    return false\n  }\n\n  function parseMarkdownCodeBlock(blocks: string[]): boolean {\n    // find and skip over a Markdown fenced code block:\n    //     ``` ... ```\n    // or\n    //     ```json ... ```\n    if (skipMarkdownCodeBlock(blocks)) {\n      if (isFunctionNameCharStart(text[i])) {\n        // strip the optional language specifier like \"json\"\n        while (i < text.length && isFunctionNameChar(text[i])) {\n          i++\n        }\n      }\n\n      parseWhitespaceAndSkipComments()\n\n      return true\n    }\n\n    return false\n  }\n\n  function skipMarkdownCodeBlock(blocks: string[]): boolean {\n    for (const block of blocks) {\n      const end = i + block.length\n      if (text.slice(i, end) === block) {\n        i = end\n        return true\n      }\n    }\n\n    return false\n  }\n\n  function parseCharacter(char: string): boolean {\n    if (text[i] === char) {\n      output += text[i]\n      i++\n      return true\n    }\n\n    return false\n  }\n\n  function skipCharacter(char: string): boolean {\n    if (text[i] === char) {\n      i++\n      return true\n    }\n\n    return false\n  }\n\n  function skipEscapeCharacter(): boolean {\n    return skipCharacter('\\\\')\n  }\n\n  /**\n   * Skip ellipsis like \"[1,2,3,...]\" or \"[1,2,3,...,9]\" or \"[...,7,8,9]\"\n   * or a similar construct in objects.\n   */\n  function skipEllipsis(): boolean {\n    parseWhitespaceAndSkipComments()\n\n    if (text[i] === '.' && text[i + 1] === '.' && text[i + 2] === '.') {\n      // repair: remove the ellipsis (three dots) and optionally a comma\n      i += 3\n      parseWhitespaceAndSkipComments()\n      skipCharacter(',')\n\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * Parse an object like '{\"key\": \"value\"}'\n   */\n  function parseObject(): boolean {\n    if (text[i] === '{') {\n      output += '{'\n      i++\n      parseWhitespaceAndSkipComments()\n\n      // repair: skip leading comma like in {, message: \"hi\"}\n      if (skipCharacter(',')) {\n        parseWhitespaceAndSkipComments()\n      }\n\n      let initial = true\n      while (i < text.length && text[i] !== '}') {\n        let processedComma: boolean\n        if (!initial) {\n          processedComma = parseCharacter(',')\n          if (!processedComma) {\n            // repair missing comma\n            output = insertBeforeLastWhitespace(output, ',')\n          }\n          parseWhitespaceAndSkipComments()\n        } else {\n          processedComma = true\n          initial = false\n        }\n\n        skipEllipsis()\n\n        const processedKey = parseString() || parseUnquotedString(true)\n        if (!processedKey) {\n          if (\n            text[i] === '}' ||\n            text[i] === '{' ||\n            text[i] === ']' ||\n            text[i] === '[' ||\n            text[i] === undefined\n          ) {\n            // repair trailing comma\n            output = stripLastOccurrence(output, ',')\n          } else {\n            throwObjectKeyExpected()\n          }\n          break\n        }\n\n        parseWhitespaceAndSkipComments()\n        const processedColon = parseCharacter(':')\n        const truncatedText = i >= text.length\n        if (!processedColon) {\n          if (isStartOfValue(text[i]) || truncatedText) {\n            // repair missing colon\n            output = insertBeforeLastWhitespace(output, ':')\n          } else {\n            throwColonExpected()\n          }\n        }\n        const processedValue = parseValue()\n        if (!processedValue) {\n          if (processedColon || truncatedText) {\n            // repair missing object value\n            output += 'null'\n          } else {\n            throwColonExpected()\n          }\n        }\n      }\n\n      if (text[i] === '}') {\n        output += '}'\n        i++\n      } else {\n        // repair missing end bracket\n        output = insertBeforeLastWhitespace(output, '}')\n      }\n\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * Parse an array like '[\"item1\", \"item2\", ...]'\n   */\n  function parseArray(): boolean {\n    if (text[i] === '[') {\n      output += '['\n      i++\n      parseWhitespaceAndSkipComments()\n\n      // repair: skip leading comma like in [,1,2,3]\n      if (skipCharacter(',')) {\n        parseWhitespaceAndSkipComments()\n      }\n\n      let initial = true\n      while (i < text.length && text[i] !== ']') {\n        if (!initial) {\n          const processedComma = parseCharacter(',')\n          if (!processedComma) {\n            // repair missing comma\n            output = insertBeforeLastWhitespace(output, ',')\n          }\n        } else {\n          initial = false\n        }\n\n        skipEllipsis()\n\n        const processedValue = parseValue()\n        if (!processedValue) {\n          // repair trailing comma\n          output = stripLastOccurrence(output, ',')\n          break\n        }\n      }\n\n      if (text[i] === ']') {\n        output += ']'\n        i++\n      } else {\n        // repair missing closing array bracket\n        output = insertBeforeLastWhitespace(output, ']')\n      }\n\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * Parse and repair Newline Delimited JSON (NDJSON):\n   * multiple JSON objects separated by a newline character\n   */\n  function parseNewlineDelimitedJSON() {\n    // repair NDJSON\n    let initial = true\n    let processedValue = true\n    while (processedValue) {\n      if (!initial) {\n        // parse optional comma, insert when missing\n        const processedComma = parseCharacter(',')\n        if (!processedComma) {\n          // repair: add missing comma\n          output = insertBeforeLastWhitespace(output, ',')\n        }\n      } else {\n        initial = false\n      }\n\n      processedValue = parseValue()\n    }\n\n    if (!processedValue) {\n      // repair: remove trailing comma\n      output = stripLastOccurrence(output, ',')\n    }\n\n    // repair: wrap the output inside array brackets\n    output = `[\\n${output}\\n]`\n  }\n\n  /**\n   * Parse a string enclosed by double quotes \"...\". Can contain escaped quotes\n   * Repair strings enclosed in single quotes or special quotes\n   * Repair an escaped string\n   *\n   * The function can run in two stages:\n   * - First, it assumes the string has a valid end quote\n   * - If it turns out that the string does not have a valid end quote followed\n   *   by a delimiter (which should be the case), the function runs again in a\n   *   more conservative way, stopping the string at the first next delimiter\n   *   and fixing the string by inserting a quote there, or stopping at a\n   *   stop index detected in the first iteration.\n   */\n  function parseString(stopAtDelimiter = false, stopAtIndex = -1): boolean {\n    let skipEscapeChars = text[i] === '\\\\'\n    if (skipEscapeChars) {\n      // repair: remove the first escape character\n      i++\n      skipEscapeChars = true\n    }\n\n    if (isQuote(text[i])) {\n      // double quotes are correct JSON,\n      // single quotes come from JavaScript for example, we assume it will have a correct single end quote too\n      // otherwise, we will match any double-quote-like start with a double-quote-like end,\n      // or any single-quote-like start with a single-quote-like end\n      const isEndQuote = isDoubleQuote(text[i])\n        ? isDoubleQuote\n        : isSingleQuote(text[i])\n          ? isSingleQuote\n          : isSingleQuoteLike(text[i])\n            ? isSingleQuoteLike\n            : isDoubleQuoteLike\n\n      const iBefore = i\n      const oBefore = output.length\n\n      let str = '\"'\n      i++\n\n      while (true) {\n        if (i >= text.length) {\n          // end of text, we are missing an end quote\n\n          const iPrev = prevNonWhitespaceIndex(i - 1)\n          if (!stopAtDelimiter && isDelimiter(text.charAt(iPrev))) {\n            // if the text ends with a delimiter, like [\"hello],\n            // so the missing end quote should be inserted before this delimiter\n            // retry parsing the string, stopping at the first next delimiter\n            i = iBefore\n            output = output.substring(0, oBefore)\n\n            return parseString(true)\n          }\n\n          // repair missing quote\n          str = insertBeforeLastWhitespace(str, '\"')\n          output += str\n\n          return true\n        }\n\n        if (i === stopAtIndex) {\n          // use the stop index detected in the first iteration, and repair end quote\n          str = insertBeforeLastWhitespace(str, '\"')\n          output += str\n\n          return true\n        }\n\n        if (isEndQuote(text[i])) {\n          // end quote\n          // let us check what is before and after the quote to verify whether this is a legit end quote\n          const iQuote = i\n          const oQuote = str.length\n          str += '\"'\n          i++\n          output += str\n\n          parseWhitespaceAndSkipComments(false)\n\n          if (\n            stopAtDelimiter ||\n            i >= text.length ||\n            isDelimiter(text[i]) ||\n            isQuote(text[i]) ||\n            isDigit(text[i])\n          ) {\n            // The quote is followed by the end of the text, a delimiter,\n            // or a next value. So the quote is indeed the end of the string.\n            parseConcatenatedString()\n\n            return true\n          }\n\n          const iPrevChar = prevNonWhitespaceIndex(iQuote - 1)\n          const prevChar = text.charAt(iPrevChar)\n\n          if (prevChar === ',') {\n            // A comma followed by a quote, like '{\"a\":\"b,c,\"d\":\"e\"}'.\n            // We assume that the quote is a start quote, and that the end quote\n            // should have been located right before the comma but is missing.\n            i = iBefore\n            output = output.substring(0, oBefore)\n\n            return parseString(false, iPrevChar)\n          }\n\n          if (isDelimiter(prevChar)) {\n            // This is not the right end quote: it is preceded by a delimiter,\n            // and NOT followed by a delimiter. So, there is an end quote missing\n            // parse the string again and then stop at the first next delimiter\n            i = iBefore\n            output = output.substring(0, oBefore)\n\n            return parseString(true)\n          }\n\n          // revert to right after the quote but before any whitespace, and continue parsing the string\n          output = output.substring(0, oBefore)\n          i = iQuote + 1\n\n          // repair unescaped quote\n          str = `${str.substring(0, oQuote)}\\\\${str.substring(oQuote)}`\n        } else if (stopAtDelimiter && isUnquotedStringDelimiter(text[i])) {\n          // we're in the mode to stop the string at the first delimiter\n          // because there is an end quote missing\n\n          // test start of an url like \"https://...\" (this would be parsed as a comment)\n          if (text[i - 1] === ':' && regexUrlStart.test(text.substring(iBefore + 1, i + 2))) {\n            while (i < text.length && regexUrlChar.test(text[i])) {\n              str += text[i]\n              i++\n            }\n          }\n\n          // repair missing quote\n          str = insertBeforeLastWhitespace(str, '\"')\n          output += str\n\n          parseConcatenatedString()\n\n          return true\n        } else if (text[i] === '\\\\') {\n          // handle escaped content like \\n or \\u2605\n          const char = text.charAt(i + 1)\n          const escapeChar = escapeCharacters[char]\n          if (escapeChar !== undefined) {\n            str += text.slice(i, i + 2)\n            i += 2\n          } else if (char === 'u') {\n            let j = 2\n            while (j < 6 && isHex(text[i + j])) {\n              j++\n            }\n\n            if (j === 6) {\n              str += text.slice(i, i + 6)\n              i += 6\n            } else if (i + j >= text.length) {\n              // repair invalid or truncated unicode char at the end of the text\n              // by removing the unicode char and ending the string here\n              i = text.length\n            } else {\n              throwInvalidUnicodeCharacter()\n            }\n          } else {\n            // repair invalid escape character: remove it\n            str += char\n            i += 2\n          }\n        } else {\n          // handle regular characters\n          const char = text.charAt(i)\n\n          if (char === '\"' && text[i - 1] !== '\\\\') {\n            // repair unescaped double quote\n            str += `\\\\${char}`\n            i++\n          } else if (isControlCharacter(char)) {\n            // unescaped control character\n            str += controlCharacters[char]\n            i++\n          } else {\n            if (!isValidStringCharacter(char)) {\n              throwInvalidCharacter(char)\n            }\n            str += char\n            i++\n          }\n        }\n\n        if (skipEscapeChars) {\n          // repair: skipped escape character (nothing to do)\n          skipEscapeCharacter()\n        }\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Repair concatenated strings like \"hello\" + \"world\", change this into \"helloworld\"\n   */\n  function parseConcatenatedString(): boolean {\n    let processed = false\n\n    parseWhitespaceAndSkipComments()\n    while (text[i] === '+') {\n      processed = true\n      i++\n      parseWhitespaceAndSkipComments()\n\n      // repair: remove the end quote of the first string\n      output = stripLastOccurrence(output, '\"', true)\n      const start = output.length\n      const parsedStr = parseString()\n      if (parsedStr) {\n        // repair: remove the start quote of the second string\n        output = removeAtIndex(output, start, 1)\n      } else {\n        // repair: remove the + because it is not followed by a string\n        output = insertBeforeLastWhitespace(output, '\"')\n      }\n    }\n\n    return processed\n  }\n\n  /**\n   * Parse a number like 2.4 or 2.4e6\n   */\n  function parseNumber(): boolean {\n    const start = i\n    if (text[i] === '-') {\n      i++\n      if (atEndOfNumber()) {\n        repairNumberEndingWithNumericSymbol(start)\n        return true\n      }\n      if (!isDigit(text[i])) {\n        i = start\n        return false\n      }\n    }\n\n    // Note that in JSON leading zeros like \"00789\" are not allowed.\n    // We will allow all leading zeros here though and at the end of parseNumber\n    // check against trailing zeros and repair that if needed.\n    // Leading zeros can have meaning, so we should not clear them.\n    while (isDigit(text[i])) {\n      i++\n    }\n\n    if (text[i] === '.') {\n      i++\n      if (atEndOfNumber()) {\n        repairNumberEndingWithNumericSymbol(start)\n        return true\n      }\n      if (!isDigit(text[i])) {\n        i = start\n        return false\n      }\n      while (isDigit(text[i])) {\n        i++\n      }\n    }\n\n    if (text[i] === 'e' || text[i] === 'E') {\n      i++\n      if (text[i] === '-' || text[i] === '+') {\n        i++\n      }\n      if (atEndOfNumber()) {\n        repairNumberEndingWithNumericSymbol(start)\n        return true\n      }\n      if (!isDigit(text[i])) {\n        i = start\n        return false\n      }\n      while (isDigit(text[i])) {\n        i++\n      }\n    }\n\n    // if we're not at the end of the number by this point, allow this to be parsed as another type\n    if (!atEndOfNumber()) {\n      i = start\n      return false\n    }\n\n    if (i > start) {\n      // repair a number with leading zeros like \"00789\"\n      const num = text.slice(start, i)\n      const hasInvalidLeadingZero = /^0\\d/.test(num)\n\n      output += hasInvalidLeadingZero ? `\"${num}\"` : num\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * Parse keywords true, false, null\n   * Repair Python keywords True, False, None\n   */\n  function parseKeywords(): boolean {\n    return (\n      parseKeyword('true', 'true') ||\n      parseKeyword('false', 'false') ||\n      parseKeyword('null', 'null') ||\n      // repair Python keywords True, False, None\n      parseKeyword('True', 'true') ||\n      parseKeyword('False', 'false') ||\n      parseKeyword('None', 'null')\n    )\n  }\n\n  function parseKeyword(name: string, value: string): boolean {\n    if (text.slice(i, i + name.length) === name) {\n      output += value\n      i += name.length\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * Repair an unquoted string by adding quotes around it\n   * Repair a MongoDB function call like NumberLong(\"2\")\n   * Repair a JSONP function call like callback({...});\n   */\n  function parseUnquotedString(isKey: boolean) {\n    // note that the symbol can end with whitespaces: we stop at the next delimiter\n    // also, note that we allow strings to contain a slash / in order to support repairing regular expressions\n    const start = i\n\n    if (isFunctionNameCharStart(text[i])) {\n      while (i < text.length && isFunctionNameChar(text[i])) {\n        i++\n      }\n\n      let j = i\n      while (isWhitespace(text, j)) {\n        j++\n      }\n\n      if (text[j] === '(') {\n        // repair a MongoDB function call like NumberLong(\"2\")\n        // repair a JSONP function call like callback({...});\n        i = j + 1\n\n        parseValue()\n\n        if (text[i] === ')') {\n          // repair: skip close bracket of function call\n          i++\n          if (text[i] === ';') {\n            // repair: skip semicolon after JSONP call\n            i++\n          }\n        }\n\n        return true\n      }\n    }\n\n    while (\n      i < text.length &&\n      !isUnquotedStringDelimiter(text[i]) &&\n      !isQuote(text[i]) &&\n      (!isKey || text[i] !== ':')\n    ) {\n      i++\n    }\n\n    // test start of an url like \"https://...\" (this would be parsed as a comment)\n    if (text[i - 1] === ':' && regexUrlStart.test(text.substring(start, i + 2))) {\n      while (i < text.length && regexUrlChar.test(text[i])) {\n        i++\n      }\n    }\n\n    if (i > start) {\n      // repair unquoted string\n      // also, repair undefined into null\n\n      // first, go back to prevent getting trailing whitespaces in the string\n      while (isWhitespace(text, i - 1) && i > 0) {\n        i--\n      }\n\n      const symbol = text.slice(start, i)\n      output += symbol === 'undefined' ? 'null' : JSON.stringify(symbol)\n\n      if (text[i] === '\"') {\n        // we had a missing start quote, but now we encountered the end quote, so we can skip that one\n        i++\n      }\n\n      return true\n    }\n  }\n\n  function parseRegex() {\n    if (text[i] === '/') {\n      const start = i\n      i++\n\n      while (i < text.length && (text[i] !== '/' || text[i - 1] === '\\\\')) {\n        i++\n      }\n      i++\n\n      output += `\"${text.substring(start, i)}\"`\n\n      return true\n    }\n  }\n\n  function prevNonWhitespaceIndex(start: number): number {\n    let prev = start\n\n    while (prev > 0 && isWhitespace(text, prev)) {\n      prev--\n    }\n\n    return prev\n  }\n\n  function atEndOfNumber() {\n    return i >= text.length || isDelimiter(text[i]) || isWhitespace(text, i)\n  }\n\n  function repairNumberEndingWithNumericSymbol(start: number) {\n    // repair numbers cut off at the end\n    // this will only be called when we end after a '.', '-', or 'e' and does not\n    // change the number more than it needs to make it valid JSON\n    output += `${text.slice(start, i)}0`\n  }\n\n  function throwInvalidCharacter(char: string) {\n    throw new JSONRepairError(`Invalid character ${JSON.stringify(char)}`, i)\n  }\n\n  function throwUnexpectedCharacter() {\n    throw new JSONRepairError(`Unexpected character ${JSON.stringify(text[i])}`, i)\n  }\n\n  function throwUnexpectedEnd() {\n    throw new JSONRepairError('Unexpected end of json string', text.length)\n  }\n\n  function throwObjectKeyExpected() {\n    throw new JSONRepairError('Object key expected', i)\n  }\n\n  function throwColonExpected() {\n    throw new JSONRepairError('Colon expected', i)\n  }\n\n  function throwInvalidUnicodeCharacter() {\n    const chars = text.slice(i, i + 6)\n    throw new JSONRepairError(`Invalid unicode character \"${chars}\"`, i)\n  }\n}\n\nfunction atEndOfBlockComment(text: string, i: number) {\n  return text[i] === '*' && text[i + 1] === '/'\n}\n"],
  "mappings": "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",
  "names": ["JSONRepairError", "Error", "constructor", "message", "position", "codeSpace", "codeNewline", "codeTab", "codeReturn", "codeNonBreakingSpace", "codeEnQuad", "codeHairSpace", "codeNarrowNoBreakSpace", "codeMediumMathematicalSpace", "codeIdeographicSpace", "isHex", "char", "test", "isDigit", "isValidStringCharacter", "isDelimiter", "includes", "isFunctionNameCharStart", "isFunctionNameChar", "regexUrlStart", "regexUrlChar", "isUnquotedStringDelimiter", "isStartOfValue", "isQuote", "regexStartOfValue", "isControlCharacter", "isWhitespace", "text", "index", "code", "charCodeAt", "isWhitespaceExceptNewline", "isSpecialWhitespace", "isDoubleQuoteLike", "isSingleQuoteLike", "isDoubleQuote", "isSingleQuote", "stripLastOccurrence", "textToStrip", "stripRemainingText", "arguments", "length", "undefined", "lastIndexOf", "substring", "insertBeforeLastWhitespace", "textToInsert", "removeAtIndex", "start", "count", "endsWithCommaOrNewline", "controlCharacters", "escapeCharacters", "b", "f", "n", "r", "t", "jsonrepair", "text", "i", "output", "parseMarkdownCodeBlock", "processed", "parseValue", "throwUnexpectedEnd", "processedComma", "parseCharacter", "parseWhitespaceAndSkipComments", "isStartOfValue", "endsWithCommaOrNewline", "insertBeforeLastWhitespace", "parseNewlineDelimitedJSON", "stripLastOccurrence", "length", "throwUnexpectedCharacter", "parseObject", "parseArray", "parseString", "parseNumber", "parseKeywords", "parseUnquotedString", "parseRegex", "skipNewline", "arguments", "undefined", "start", "changed", "parseWhitespace", "parseComment", "_isWhiteSpace", "isWhitespace", "isWhitespaceExceptNewline", "whitespace", "isSpecialWhitespace", "atEndOfBlockComment", "blocks", "skipMarkdownCodeBlock", "isFunctionNameCharStart", "isFunctionNameChar", "block", "end", "slice", "char", "skipCharacter", "skipEscapeCharacter", "skipEllipsis", "initial", "processedKey", "throwObjectKeyExpected", "processedColon", "truncatedText", "throwColonExpected", "processedValue", "stopAtDelimiter", "stopAtIndex", "skipEscapeChars", "isQuote", "isEndQuote", "isDoubleQuote", "isSingleQuote", "isSingleQuoteLike", "isDoubleQuoteLike", "iBefore", "oBefore", "str", "iPrev", "prevNonWhitespaceIndex", "isDelimiter", "charAt", "substring", "iQuote", "oQuote", "isDigit", "parseConcatenatedString", "iPrevChar", "prevChar", "isUnquotedStringDelimiter", "regexUrlStart", "test", "regexUrlChar", "escapeChar", "j", "isHex", "throwInvalidUnicodeCharacter", "isControlCharacter", "isValidStringCharacter", "throwInvalidCharacter", "parsedStr", "removeAtIndex", "atEndOfNumber", "repairNumberEndingWithNumericSymbol", "num", "hasInvalidLeadingZero", "parseKeyword", "name", "value", "isKey", "symbol", "JSON", "stringify", "prev", "JSONRepairError", "chars"]
}
